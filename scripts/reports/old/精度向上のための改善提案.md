# 精度向上のための改善提案

## 📅 作成日
2025年10月27日

## 🎯 目的
現在の一致率31.5%を70%以上に向上させるための具体的な改善策を提案

---

## 📊 現状分析

### 要素数の差分（総差分: 453個）

| 要素 | 実際 | 期待 | 差分 | 問題の種類 |
|-----|-----|-----|------|----------|
| Article | 14 | 14 | 0 | ✅ 完璧 |
| **Paragraph** | 32 | 37 | **-5** | ⚠️ 不足 |
| **Item** | 107 | 86 | **+21** | ⚠️ 過剰 |
| **Subitem1** | 53 | 74 | **-21** | ⚠️ 不足 |
| **Subitem2** | 120 | 82 | **+38** | ⚠️ 過剰 |
| **Subitem3** | 241 | 97 | **+144** | 🔴 大幅過剰 |
| **Subitem4** | 13 | 67 | **-54** | ⚠️ 不足 |
| **Subitem5** | 0 | 166 | **-166** | 🔴 **最大の問題** |
| List | 34 | 38 | -4 | ⚠️ 不足 |

### パターンの傾向

```
過剰: Item(+21) + Subitem2(+38) + Subitem3(+144) = +203個
不足: Paragraph(-5) + Subitem1(-21) + Subitem4(-54) + Subitem5(-166) = -246個
```

→ **浅い階層に偏りすぎている**

---

## 🔴 問題1: Subitem5が全く作成されない（-166個）

### 問題の詳細

**Subitem5の特徴:**
- ラベル: 「ア、イ、ウ、エ、オ」（カタカナ）
- 親要素: 全てSubitem4
- 階層深さ: 10（非常に深い）
- 階層パスの例:
  ```
  Paragraph → Item → Subitem1「２」 → Subitem2 → Subitem3 
    → Subitem4「（１）」 → Subitem5「ア」
  ```

**現在の実装の問題:**
```python
def get_hierarchy_level(self, label: str) -> int:
    # カタカナ（ア、イ、ウ） → 常にlevel 3を返す
    if re.match(r'^[ア-ン]+$', label):
        return 3  # ← これが問題！
```

→ **同じ「ア」でも、文脈によって異なるレベルになるべき**
  - 浅い階層の「ア」 → Subitem1（level 3）
  - 深い階層の「ア」 → Subitem5（level 7相当）

### 改善策

#### アプローチ1: 現在の深さを考慮した動的レベル判定

```python
def get_hierarchy_level_dynamic(self, label: str, current_depth: int) -> int:
    """ラベルと現在の深さを考慮して階層レベルを判定"""
    
    # 基本レベルを取得
    base_level = self.get_hierarchy_level(label)
    
    # 深さに応じてレベルを調整
    # 例: depth 5以上でカタカナ → level 7 (Subitem5相当)
    if base_level == 3 and current_depth >= 5:
        return 7  # Subitem5相当
    elif base_level == 3 and current_depth >= 3:
        return 5  # Subitem3相当
    
    return base_level
```

#### アプローチ2: ラベルの繰り返しを検出

```python
def detect_label_repetition(self, label: str, ancestors: List[str]) -> int:
    """同じラベルパターンの繰り返しを検出"""
    
    # 祖先要素の中に同じラベルタイプがあれば、より深いレベルに
    repetition_count = sum(1 for ancestor_label in ancestors 
                          if self.get_hierarchy_level(ancestor_label) == 
                             self.get_hierarchy_level(label))
    
    base_level = self.get_hierarchy_level(label)
    return base_level + repetition_count * 2
```

#### アプローチ3: 親要素のタイプから判定

```python
def determine_subitem_level_from_parent(self, parent_tag: str, label: str) -> str:
    """親要素のタイプから適切なSubitemレベルを判定"""
    
    if parent_tag == 'Subitem4':
        # Subitem4の子は必ずSubitem5
        return 'Subitem5'
    elif parent_tag == 'Subitem3':
        return 'Subitem4'
    elif parent_tag == 'Subitem2':
        return 'Subitem3'
    # ...
```

### 推奨アプローチ

**アプローチ3（親ベース判定）+ アプローチ1（深さ考慮）の組み合わせ**

理由:
1. 親要素から判定するのが最も確実
2. 深さも補助的に利用して精度を上げる
3. 既存コードへの影響が少ない

---

## 🔴 問題2: Subitem3が大幅に過剰（+144個）

### 問題の詳細

**Subitem3が過剰作成される原因:**
1. 深さベースロジックが過度に深く判定している
2. 本来Subitem1/2になるべき要素がSubitem3になっている

**具体例:**
```
実際:  Item → Subitem3「ア」  ← 間違い
期待:  Item → Subitem1「ア」  ← 正しい
```

### 改善策

#### アプローチ1: determine_element_type()の見直し

```python
def determine_element_type(self, label: str, parent_tag: str, current_depth: int) -> str:
    """要素タイプを決定（改善版）"""
    
    # 親がItemの場合
    if parent_tag == 'Item':
        # depth=0 → Subitem1（常に）
        if current_depth == 0:
            return 'Subitem1'
        # それ以外はラベルから判定
        level = self.get_hierarchy_level(label)
        if level == 3:  # カタカナ
            return 'Subitem1'
        elif level == 4:  # 括弧カタカナ
            return 'Subitem2'
        # ...
    
    # 親がSubitemの場合
    elif parent_tag.startswith('Subitem'):
        parent_level = int(parent_tag.replace('Subitem', ''))
        # 親の次のレベル
        return f'Subitem{parent_level + 1}'
    
    return 'Item'
```

#### アプローチ2: ラベルタイプの優先度を上げる

現在: 深さ > ラベルタイプ
改善: ラベルタイプ > 深さ

```python
# 深さベースの判定を補助的に使用
if level > previous_level:
    # より深いレベル → 親の子
    suggested_depth = parent_depth + 1
else:
    # ラベルタイプから判定（優先）
    suggested_depth = level - 2

# ただし、深さの制約を考慮
actual_depth = min(suggested_depth, parent_depth + 1)
```

---

## ⚠️ 問題3: Subitem2が過剰（+38個）、Subitem1が不足（-21個）

### 問題の詳細

**パターン:**
- 本来Subitem1になるべき「ア、イ、ウ」がSubitem2になっている

### 改善策

親要素がItemの場合、最初の子は**必ずSubitem1**にする：

```python
if parent_tag == 'Item':
    # Itemの直接の子は必ずSubitem1から始める
    existing_subitems = parent_elem.findall('.//Subitem1')
    if len(existing_subitems) == 0 and level >= 3:
        return 'Subitem1'  # 強制的にSubitem1
```

---

## ⚠️ 問題4: Itemが過剰（+21個）、Paragraphが不足（-5個）

### 問題の詳細

**パターン:**
- 本来Paragraphになるべき数字ラベルがItemになっている

### 改善策

数字ラベル（レベル1）の判定を厳密化：

```python
if level == 1:  # 数字パターン
    # ParagraphNumが存在しない、または空の場合
    if paragraph_num is None or paragraph_num == '':
        # 既存のParagraph内に他のItemがあるか確認
        existing_items = paragraph.findall('.//Item')
        if len(existing_items) == 0:
            # 最初のItem → 新しいParagraphとして分離
            return 'Paragraph'
    
    return 'Item'
```

---

## 📋 残りのList要素（34個）

### 特徴
- **全てColumn構造なし**（補足テキスト）
- ラベルなし

### 対応方針

これらは正常：
- Column構造なしのList要素は補足テキストとして保持
- 無理に変換する必要はない

---

## 🎯 優先順位付き改善計画

### フェーズ1: 最大の問題を解決（-166個）

**🔴 優先度: 最高**

**目標:** Subitem5を正しく作成する

**実装:**
1. `determine_element_type()`を改善
   - 親がSubitem4の場合、子は必ずSubitem5
2. `convert_lists_to_subitems()`にSubitem5-10対応を追加

**期待効果:** 
- Subitem5: 0個 → 166個（+166）
- 総差分: 453個 → 287個
- 一致率: 31.5% → 約56%

### フェーズ2: 過剰作成を抑制（-144個）

**⚠️ 優先度: 高**

**目標:** Subitem3の過剰作成を抑制

**実装:**
1. ラベルタイプを優先した判定に変更
2. Itemの直接の子は必ずSubitem1から開始

**期待効果:**
- Subitem3: 241個 → 97個（-144）
- Subitem1: 53個 → 74個（+21）
- 総差分: 287個 → 122個
- 一致率: 56% → 約81%

### フェーズ3: 細かい調整（残り）

**⚠️ 優先度: 中**

**目標:** 残りの差分を解消

**実装:**
1. Paragraph/Item判定の改善
2. Subitem2/Subitem4の調整

**期待効果:**
- 総差分: 122個 → 50個以下
- 一致率: 81% → 90%以上

---

## 📊 期待される改善効果

### 改善ロードマップ

```
現在（Phase 0）:
  一致率: 31.5%
  総差分: 453個
  ↓
フェーズ1完了後:
  一致率: 約56%
  総差分: 287個
  改善: +166個（Subitem5作成）
  ↓
フェーズ2完了後:
  一致率: 約81%
  総差分: 122個
  改善: +165個（階層修正）
  ↓
フェーズ3完了後:
  一致率: 90%以上
  総差分: 50個以下
  改善: +72個（細かい調整）
```

### 数値目標

| フェーズ | 一致率 | 総差分 | 期間 |
|---------|--------|--------|------|
| 現在 | 31.5% | 453個 | - |
| フェーズ1 | 56% | 287個 | 1日 |
| フェーズ2 | 81% | 122個 | 2-3日 |
| フェーズ3 | 90%+ | <50個 | 2-3日 |
| **合計** | **90%+** | **<50個** | **約1週間** |

---

## 🛠️ 実装の具体的なステップ

### Step 1: Subitem5対応（フェーズ1）

```python
# 1. convert_lists_to_subitems()の拡張
def convert_lists_to_subitems_extended(self, root, target_level, subitem_type):
    """Subitem5-10に対応した拡張版"""
    
    # 親要素の候補を拡張
    parent_candidates = ['Item']
    for i in range(1, target_level - 2):
        parent_candidates.append(f'Subitem{i}')
    
    # ラベルタイプではなく、親要素から判定
    # ...

# 2. メイン処理フローに追加
for level in range(7, 11):  # Subitem5-10
    subitem_type = f'Subitem{level - 2}'
    converted = converter.convert_lists_to_subitems_extended(
        root, level, subitem_type
    )
```

### Step 2: 階層判定の改善（フェーズ2）

```python
# determine_element_type()の書き換え
def determine_element_type_improved(self, label, parent_tag, current_depth):
    """改善版の要素タイプ判定"""
    
    # 1. 親ベースの判定（最優先）
    if parent_tag.startswith('Subitem'):
        parent_level = int(parent_tag.replace('Subitem', ''))
        return f'Subitem{parent_level + 1}'
    
    # 2. ラベルタイプベースの判定
    level = self.get_hierarchy_level(label)
    
    # 3. 親がItemの場合の特別処理
    if parent_tag == 'Item':
        if level == 3:  # カタカナ
            return 'Subitem1'  # 常にSubitem1
    
    # ...
```

### Step 3: テストと検証

各フェーズ完了後:
1. 単体テスト実行
2. test_input5.xmlで変換
3. test_output5.xmlと比較
4. 改善効果を測定

---

## 📌 結論

### 主な問題点（優先度順）

1. 🔴 **Subitem5が未対応**（-166個）
2. 🔴 **Subitem3の過剰作成**（+144個）
3. ⚠️ **階層判定の不正確**（Subitem1/2/4の過不足）
4. ⚠️ **Paragraph/Item判定**（軽微）

### 解決策の核心

**現在:** ラベルタイプだけで判定
```python
「ア」 → 常にlevel 3 → Subitem1
```

**改善後:** 親要素と深さも考慮
```python
親がItem + 「ア」 → Subitem1
親がSubitem4 + 「ア」 → Subitem5
```

### 期待される成果

- **一致率**: 31.5% → 90%以上
- **総差分**: 453個 → 50個以下
- **実装期間**: 約1週間
- **段階的な改善**: 各フェーズで検証しながら進行

---

**次のステップ:** フェーズ1（Subitem5対応）から実装開始

